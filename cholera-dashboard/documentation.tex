\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{titlesec}

\geometry{margin=1in}

% Code listing style
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    showstringspaces=false
}

% Title formatting
\titleformat{\section}
{\Large\bfseries}
{}
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large\bfseries}
{}
{0em}
{}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Cholera Watch - Technical Documentation},
    pdfauthor={Cholera Watch Development Team}
}

\title{\textbf{Cholera Watch: Health Intelligence Platform}\\
\large Technical Documentation and Methodology}
\author{Development Team}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document provides comprehensive technical documentation for the Cholera Watch platform, a health intelligence dashboard system designed for monitoring, analyzing, and forecasting cholera outbreaks in Uganda. The system integrates interactive data visualization, machine learning-powered forecasting, and comprehensive analytics to support public health decision-making. This documentation covers the system architecture, methodology, technology stack, machine learning model selection rationale, feature engineering approaches, and deployment strategies.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

\subsection{Overview}
Cholera Watch is a comprehensive web-based health intelligence platform designed to monitor, analyze, and predict cholera outbreaks in Uganda. The system processes surveillance data from 2011 to 2024, providing real-time insights, trend analysis, and machine learning-powered forecasts to support public health interventions and resource allocation decisions.

\subsection{Objectives}
\begin{itemize}
    \item Provide real-time visualization of cholera surveillance data
    \item Enable comprehensive analysis of outbreak patterns and trends
    \item Generate accurate short-term and long-term forecasts using machine learning
    \item Support evidence-based decision-making for public health interventions
    \item Facilitate resource allocation planning through risk assessment
    \item Enable early warning detection through anomaly identification
\end{itemize}

\subsection{Data Scope}
The platform processes cholera surveillance data covering:
\begin{itemize}
    \item \textbf{Time Period}: 2011-2024 (14 years of historical data)
    \item \textbf{Geographic Coverage}: All districts across Uganda's four regions (Central, Eastern, Northern, Western)
    \item \textbf{Key Metrics}: Suspected cases (sCh), Confirmed cases (cCh), Deaths, Case Fatality Rate (CFR), Positivity rates
    \item \textbf{Data Granularity}: Daily, weekly, monthly, and annual aggregations
\end{itemize}

\section{System Architecture}

\subsection{High-Level Architecture}
The Cholera Watch platform follows a modern three-tier architecture:

\begin{enumerate}
    \item \textbf{Presentation Layer}: React-based single-page application (SPA) with responsive design
    \item \textbf{Application Layer}: Flask REST API for machine learning predictions
    \item \textbf{Data Layer}: CSV-based data storage with in-memory processing
\end{enumerate}

\subsection{Component Architecture}

\subsubsection{Frontend Architecture}
The frontend is built as a modular React application with the following structure:

\begin{itemize}
    \item \textbf{Pages}: Route-based page components (Overview, Analytics, Response Insights, Early Warning, Resource Planning)
    \item \textbf{Components}: Reusable UI components (charts, maps, modals, cards)
    \item \textbf{Utils}: Data transformation and utility functions
    \item \textbf{Hooks}: Custom React hooks for data management
\end{itemize}

\subsubsection{Backend Architecture}
The backend consists of a Flask-based REST API with the following components:

\begin{itemize}
    \item \textbf{API Endpoints}: Health check and prediction endpoints
    \item \textbf{Model Loader}: Lazy-loading mechanism for machine learning models
    \item \textbf{Feature Engineering}: Real-time feature construction from input data
    \item \textbf{Prediction Engine}: Model inference and result transformation
\end{itemize}

\subsection{Data Flow}
\begin{enumerate}
    \item User interacts with the frontend dashboard
    \item Frontend requests data from CSV files (client-side parsing)
    \item User triggers forecast generation
    \item Frontend sends feature data to Flask API
    \item API performs feature engineering and model inference
    \item API returns predictions to frontend
    \item Frontend visualizes results using Recharts
\end{enumerate}

\section{Methodology}

\subsection{Data Processing Pipeline}

\subsubsection{Data Ingestion}
The system processes CSV files containing cholera surveillance data. The data transformation pipeline includes:

\begin{itemize}
    \item \textbf{Parsing}: CSV parsing using PapaParse library
    \item \textbf{Validation}: Data type validation and error handling
    \item \textbf{Normalization}: Date standardization and region mapping
    \item \textbf{Aggregation}: Multi-level aggregation (daily, weekly, monthly, annual)
\end{itemize}

\subsubsection{Data Transformation}
The \texttt{dataTransforms.js} utility provides comprehensive data transformation functions:

\begin{itemize}
    \item \textbf{Date Filtering}: Filter data by date ranges (2011-2024)
    \item \textbf{Aggregation Functions}: Calculate totals, averages, and rates
    \item \textbf{Breakdown Analysis}: Generate regional, temporal, and district-level breakdowns
    \item \textbf{Insight Generation}: Build insights for response planning and early warning
\end{itemize}

\subsection{Visualization Methodology}

\subsubsection{Interactive Maps}
The system uses Leaflet.js for choropleth mapping:
\begin{itemize}
    \item District-level case visualization
    \item Color-coded intensity scales
    \item Hover tooltips with detailed statistics
    \item Administrative map styling (Tableau-inspired)
\end{itemize}

\subsubsection{Time Series Analysis}
Recharts library provides multiple visualization types:
\begin{itemize}
    \item \textbf{Area Charts}: Trend visualization over time
    \item \textbf{Line Charts}: Multi-metric comparisons
    \item \textbf{Scatter Plots}: Relationship analysis (sCh vs cCh)
    \item \textbf{Bar Charts}: Distribution and comparison views
    \item \textbf{Pie Charts}: Proportional breakdowns
\end{itemize}

\subsection{Machine Learning Methodology}

\subsubsection{Model Selection Process}
The system employs a hierarchical model selection approach:

\begin{enumerate}
    \item \textbf{Voting Ensemble} (Primary): Combines multiple base models for robust predictions
    \item \textbf{ElasticNet} (Fallback 1): Balanced L1/L2 regularization
    \item \textbf{Ridge Regression} (Fallback 2): L2 regularization for multicollinearity
    \item \textbf{XGBoost} (Fallback 3): Gradient boosting for non-linear patterns
    \item \textbf{Lasso Regression} (Fallback 4): L1 regularization for feature selection
\end{enumerate}

\subsubsection{Feature Engineering}
The system constructs 36 features from input data:

\textbf{Temporal Features (6 features)}:
\begin{itemize}
    \item Year, Month, Quarter
    \item Day of year, Week of year
    \item Weekend indicator
\end{itemize}

\textbf{Cyclical Encoding (4 features)}:
\begin{itemize}
    \item $\sin(2\pi \cdot \text{month}/12)$, $\cos(2\pi \cdot \text{month}/12)$
    \item $\sin(2\pi \cdot \text{day}/365)$, $\cos(2\pi \cdot \text{day}/365)$
\end{itemize}

\textbf{Basic Features (5 features)}:
\begin{itemize}
    \item Duration (days), Deaths, CFR
    \item High confidence indicator, Outbreak indicator
\end{itemize}

\textbf{Lag Features (4 features)}:
\begin{itemize}
    \item sCh at lags: 1, 7, 14, 30 days
\end{itemize}

\textbf{Rolling Statistics (9 features)}:
\begin{itemize}
    \item Rolling mean, std, max for windows: 7, 14, 30 days
\end{itemize}

\textbf{Exponential Moving Average (2 features)}:
\begin{itemize}
    \item EMA with $\alpha$ for 7 and 14-day windows
\end{itemize}

\textbf{Difference Features (2 features)}:
\begin{itemize}
    \item First difference: $\Delta sCh_t = sCh_t - sCh_{t-1}$
    \item Percentage change: $\frac{\Delta sCh_t}{sCh_{t-1}} \times 100$
\end{itemize}

\textbf{Geographic Features (4 features)}:
\begin{itemize}
    \item One-hot encoding for regions: Central, Eastern, Northern, Western
\end{itemize}

\subsubsection{Prediction Pipeline}
\begin{enumerate}
    \item Receive input data (current metrics + historical context)
    \item Build 36-dimensional feature vector
    \item Load appropriate model (Voting Ensemble preferred)
    \item Generate raw prediction
    \item Apply post-processing transformations
    \item Return prediction with metadata
\end{enumerate}

\section{Technology Stack and Libraries}

\subsection{Frontend Technologies}

\subsubsection{Core Framework}
\begin{itemize}
    \item \textbf{React 19.2.0}: Modern UI library for building interactive interfaces
    \item \textbf{Vite 7.2.2}: Fast build tool and development server
    \item \textbf{React Router DOM 7.9.6}: Client-side routing for SPA navigation
\end{itemize}

\subsubsection{Visualization Libraries}
\begin{itemize}
    \item \textbf{Recharts 3.4.1}: React charting library built on D3.js
    \begin{itemize}
        \item Provides: AreaChart, LineChart, ScatterChart, BarChart, PieChart
        \item Features: Responsive containers, interactive tooltips, legends
        \item Advantages: React-native, declarative API, extensive customization
    \end{itemize}
    \item \textbf{Leaflet 1.9.4}: Open-source mapping library
    \begin{itemize}
        \item Provides: Interactive maps, tile layers, GeoJSON rendering
        \item Integration: React-Leaflet 5.0.0 for React bindings
    \end{itemize}
\end{itemize}

\subsubsection{UI/UX Libraries}
\begin{itemize}
    \item \textbf{Framer Motion 12.23.24}: Animation library for React
    \begin{itemize}
        \item Provides: Page transitions, component animations, gesture support
        \item Features: Spring physics, layout animations, scroll-triggered animations
    \end{itemize}
    \item \textbf{Date-fns 4.1.0}: Date utility library
    \begin{itemize}
        \item Provides: Date parsing, formatting, manipulation functions
    \end{itemize}
\end{itemize}

\subsubsection{Data Processing}
\begin{itemize}
    \item \textbf{PapaParse 5.5.3}: CSV parsing library
    \begin{itemize}
        \item Provides: Fast CSV parsing, streaming support, error handling
    \end{itemize}
\end{itemize}

\subsection{Backend Technologies}

\subsubsection{Web Framework}
\begin{itemize}
    \item \textbf{Flask 3.0.0}: Lightweight Python web framework
    \begin{itemize}
        \item Provides: REST API endpoints, request handling, JSON responses
    \end{itemize}
    \item \textbf{Flask-CORS 4.0.0}: Cross-Origin Resource Sharing support
    \begin{itemize}
        \item Enables: Frontend-backend communication across origins
    \end{itemize}
\end{itemize}

\subsubsection{Machine Learning Libraries}
\begin{itemize}
    \item \textbf{Scikit-learn $\geq$ 1.4.0}: Comprehensive ML library
    \begin{itemize}
        \item Provides: Linear models (Lasso, Ridge, ElasticNet), ensemble methods (Voting Regressor)
        \item Features: Model persistence, preprocessing, evaluation metrics
    \end{itemize}
    \item \textbf{XGBoost $\geq$ 2.0.0}: Gradient boosting framework
    \begin{itemize}
        \item Provides: High-performance gradient boosting, feature importance
        \item Advantages: Handles non-linear relationships, missing values
    \end{itemize}
    \item \textbf{NumPy $\geq$ 1.24.3}: Numerical computing library
    \begin{itemize}
        \item Provides: Array operations, mathematical functions, linear algebra
    \end{itemize}
    \item \textbf{Pandas $\geq$ 2.0.0}: Data manipulation library
    \begin{itemize}
        \item Provides: DataFrames, time series operations, data cleaning
    \end{itemize}
    \item \textbf{Joblib $\geq$ 1.0.0}: Model persistence library
    \begin{itemize}
        \item Provides: Efficient model serialization, parallel processing
    \end{itemize}
\end{itemize}

\subsection{Development Tools}
\begin{itemize}
    \item \textbf{ESLint 9.39.1}: JavaScript linter for code quality
    \item \textbf{TypeScript Types}: Type definitions for React and React-DOM
    \item \textbf{Git}: Version control system
    \item \textbf{Node.js $\geq$ 18.0.0}: JavaScript runtime
    \item \textbf{Python 3.9+}: Python runtime for backend
\end{itemize}

\section{Machine Learning Models}

\subsection{Model Selection Rationale}

The Cholera Watch platform employs a hierarchical model selection strategy, prioritizing models based on performance, robustness, and interpretability. The Voting Ensemble model serves as the primary prediction engine due to its superior performance characteristics.

\subsection{Voting Ensemble Model}

\subsubsection{Architecture}
The Voting Ensemble combines multiple base regressors using a weighted averaging approach:

\begin{equation}
\hat{y}_{\text{ensemble}} = \sum_{i=1}^{n} w_i \cdot \hat{y}_i
\end{equation}

where:
\begin{itemize}
    \item $n$ = number of base models
    \item $w_i$ = weight for model $i$ (typically uniform: $w_i = 1/n$)
    \item $\hat{y}_i$ = prediction from model $i$
\end{itemize}

\subsubsection{Base Models}
The Voting Ensemble integrates four base models:

\begin{enumerate}
    \item \textbf{Linear Regression}: Baseline linear model
    \begin{itemize}
        \item Formula: $\hat{y} = \beta_0 + \sum_{j=1}^{p} \beta_j x_j$
        \item Advantages: Interpretable, fast, no hyperparameters
        \item Limitations: Assumes linear relationships
    \end{itemize}
    
    \item \textbf{Ridge Regression}: L2-regularized linear model
    \begin{itemize}
        \item Formula: $\hat{y} = \arg\min_{\beta} \left[ \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 + \lambda \sum_{j=1}^{p} \beta_j^2 \right]$
        \item Advantages: Handles multicollinearity, prevents overfitting
        \item Hyperparameter: $\lambda$ (regularization strength)
    \end{itemize}
    
    \item \textbf{Lasso Regression}: L1-regularized linear model
    \begin{itemize}
        \item Formula: $\hat{y} = \arg\min_{\beta} \left[ \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 + \lambda \sum_{j=1}^{p} |\beta_j| \right]$
        \item Advantages: Feature selection, sparse solutions
        \item Hyperparameter: $\lambda$ (regularization strength)
    \end{itemize}
    
    \item \textbf{ElasticNet}: Combined L1/L2 regularization
    \begin{itemize}
        \item Formula: $\hat{y} = \arg\min_{\beta} \left[ \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 + \lambda_1 \sum_{j=1}^{p} |\beta_j| + \lambda_2 \sum_{j=1}^{p} \beta_j^2 \right]$
        \item Advantages: Combines benefits of Ridge and Lasso
        \item Hyperparameters: $\lambda_1$ (L1), $\lambda_2$ (L2), $\alpha$ (mixing ratio)
    \end{itemize}
\end{enumerate}

\subsubsection{Why Voting Ensemble?}

\textbf{1. Robustness and Generalization}
\begin{itemize}
    \item \textbf{Reduced Variance}: Averaging predictions from multiple models reduces prediction variance
    \item \textbf{Error Reduction}: Different models make different errors; averaging mitigates individual model failures
    \item \textbf{Stability}: Less sensitive to outliers and data perturbations
\end{itemize}

\textbf{2. Performance Metrics}
Based on evaluation, the Voting Ensemble achieved:
\begin{itemize}
    \item \textbf{Root Mean Squared Error (RMSE)}: $\approx$ 10 cases
    \item \textbf{Coefficient of Determination ($R^2$)}: $\approx$ 0.98
    \item \textbf{Mean Absolute Error (MAE)}: Lower than individual models
\end{itemize}

\textbf{3. Complementary Strengths}
Each base model contributes unique strengths:
\begin{itemize}
    \item \textbf{Linear Regression}: Captures global trends and baseline patterns
    \item \textbf{Ridge}: Handles correlated features (temporal lags, rolling stats)
    \item \textbf{Lasso}: Selects most important features from 36-dimensional space
    \item \textbf{ElasticNet}: Balances feature selection with multicollinearity handling
\end{itemize}

\textbf{4. Interpretability}
\begin{itemize}
    \item Linear models are inherently interpretable
    \item Feature importance can be derived from coefficients
    \item Ensemble predictions can be decomposed into base model contributions
\end{itemize}

\textbf{5. Computational Efficiency}
\begin{itemize}
    \item Linear models are fast to train and predict
    \item No complex hyperparameter tuning required
    \item Suitable for real-time prediction scenarios
\end{itemize}

\subsection{Alternative Models}

\subsubsection{XGBoost}
\begin{itemize}
    \item \textbf{Type}: Gradient Boosting Decision Trees
    \item \textbf{Advantages}: Handles non-linear relationships, feature interactions
    \item \textbf{Limitations}: 
    \begin{itemize}
        \item Larger model size (memory constraints)
        \item Longer prediction time
        \item Less interpretable than linear models
        \item Requires extensive hyperparameter tuning
    \end{itemize}
    \item \textbf{Use Case}: Fallback when non-linear patterns are dominant
\end{itemize}

\subsubsection{Individual Linear Models}
\begin{itemize}
    \item \textbf{Ridge Regression}: Best for multicollinearity scenarios
    \item \textbf{Lasso Regression}: Best for feature selection scenarios
    \item \textbf{ElasticNet}: Best for balanced regularization needs
    \item \textbf{Limitation}: Single models are more prone to overfitting and variance
\end{itemize}

\subsection{Model Training Process}

\subsubsection{Data Preparation}
\begin{enumerate}
    \item Load historical data (2011-2024)
    \item Engineer 36 features for each observation
    \item Split data: 80\% training, 20\% testing
    \item Handle missing values and outliers
\end{enumerate}

\subsubsection{Training Procedure}
\begin{enumerate}
    \item Train each base model independently
    \item Perform cross-validation for hyperparameter tuning
    \item Evaluate individual model performance
    \item Combine models using Voting Regressor
    \item Evaluate ensemble performance
    \item Persist model using Joblib
\end{enumerate}

\subsubsection{Model Persistence}
Models are saved using Joblib for efficient serialization:
\begin{itemize}
    \item Format: \texttt{.pkl} files
    \item Location: Parent directory (Cholera folder)
    \item Loading: Lazy loading on first prediction request
\end{itemize}

\section{Feature Engineering}

\subsection{Feature Categories}

\subsubsection{Temporal Features}
Capture time-based patterns:
\begin{itemize}
    \item \textbf{Year}: Long-term trends
    \item \textbf{Month}: Seasonal patterns
    \item \textbf{Quarter}: Quarterly cycles
    \item \textbf{Day of Year}: Annual seasonality
    \item \textbf{Week of Year}: Weekly patterns
    \item \textbf{Weekend Indicator}: Weekly periodicity
\end{itemize}

\subsubsection{Cyclical Encoding}
Transform temporal features to capture cyclicality:
\begin{align}
\sin_{\text{month}} &= \sin\left(\frac{2\pi \cdot \text{month}}{12}\right) \\
\cos_{\text{month}} &= \cos\left(\frac{2\pi \cdot \text{month}}{12}\right) \\
\sin_{\text{day}} &= \sin\left(\frac{2\pi \cdot \text{day}}{365}\right) \\
\cos_{\text{day}} &= \cos\left(\frac{2\pi \cdot \text{day}}{365}\right)
\end{align}

\textbf{Rationale}: Linear models cannot inherently capture cyclical patterns. Sinusoidal encoding allows models to learn periodic relationships.

\subsubsection{Lag Features}
Capture temporal dependencies:
\begin{itemize}
    \item $sCh_{t-1}$: Previous day's cases
    \item $sCh_{t-7}$: Week-ago cases
    \item $sCh_{t-14}$: Two-week-ago cases
    \item $sCh_{t-30}$: Month-ago cases
\end{itemize}

\textbf{Rationale}: Cholera cases exhibit temporal autocorrelation. Recent history is predictive of future cases.

\subsubsection{Rolling Statistics}
Capture short-term trends and volatility:
\begin{itemize}
    \item \textbf{Mean}: $\bar{x}_w = \frac{1}{w} \sum_{i=t-w}^{t} x_i$
    \item \textbf{Standard Deviation}: $\sigma_w = \sqrt{\frac{1}{w} \sum_{i=t-w}^{t} (x_i - \bar{x}_w)^2}$
    \item \textbf{Maximum}: $\max_w = \max\{x_{t-w}, \ldots, x_t\}$
    \item \textbf{Windows}: 7, 14, 30 days
\end{itemize}

\textbf{Rationale}: Captures recent trends, volatility, and peak values that indicate outbreak intensity.

\subsubsection{Exponential Moving Average (EMA)}
Weighted average emphasizing recent values:
\begin{equation}
\text{EMA}_t = \alpha \cdot x_t + (1-\alpha) \cdot \text{EMA}_{t-1}
\end{equation}

where $\alpha = \frac{2}{w+1}$ for window $w$.

\textbf{Rationale}: Provides smoothed trend indicators that are more responsive to recent changes than simple moving averages.

\subsubsection{Difference Features}
Capture rate of change:
\begin{itemize}
    \item \textbf{First Difference}: $\Delta x_t = x_t - x_{t-1}$
    \item \textbf{Percentage Change}: $\%\Delta x_t = \frac{x_t - x_{t-1}}{x_{t-1}} \times 100$
\end{itemize}

\textbf{Rationale}: Identifies acceleration or deceleration in case growth, critical for outbreak detection.

\subsubsection{Contextual Features}
Capture outbreak context:
\begin{itemize}
    \item \textbf{Duration}: Reporting period length
    \item \textbf{Deaths}: Mortality indicator
    \item \textbf{CFR}: Case Fatality Rate
    \item \textbf{High Confidence}: Data quality indicator
    \item \textbf{Outbreak Indicator}: Binary flag (cases > threshold)
\end{itemize}

\subsubsection{Geographic Features}
One-hot encoding for regions:
\begin{itemize}
    \item Central, Eastern, Northern, Western
\end{itemize}

\textbf{Rationale}: Different regions may have different baseline rates, seasonality patterns, and risk factors.

\subsection{Feature Engineering Implementation}

The feature engineering is implemented in the \texttt{build\_features()} function in \texttt{api/predict.py}. The function:

\begin{enumerate}
    \item Extracts input parameters from request data
    \item Computes temporal features from date information
    \item Applies cyclical encoding transformations
    \item Processes historical data for lag and rolling features
    \item Calculates EMA using exponential smoothing
    \item Computes difference and percentage change features
    \item Encodes geographic region as one-hot vector
    \item Returns 36-dimensional feature array
\end{enumerate}

\section{System Components}

\subsection{Frontend Pages}

\subsubsection{Overview Page}
\begin{itemize}
    \item \textbf{Purpose}: High-level dashboard with key metrics
    \item \textbf{Components}: Summary cards, interactive map, trend charts
    \item \textbf{Interactivity}: Clickable cards trigger detailed breakdown modals
    \item \textbf{Visualizations}: Choropleth map, area charts, scatter plot
\end{itemize}

\subsubsection{Analytics Page}
\begin{itemize}
    \item \textbf{Purpose}: Deep-dive analysis of historical trends
    \item \textbf{Components}: Time series charts, distribution analysis, seasonality patterns
    \item \textbf{Features}: Date range filtering, metric selection, export capabilities
    \item \textbf{Visualizations}: Multi-line charts, bar charts, pie charts
\end{itemize}

\subsubsection{Response Insights Page}
\begin{itemize}
    \item \textbf{Purpose}: Analyze outbreak response effectiveness
    \item \textbf{Components}: Spread pattern analysis, threshold monitoring, risk factor identification
    \item \textbf{Features}: Outbreak detection, transmission pattern analysis, vulnerable population assessment
    \item \textbf{Visualizations}: Heatmaps, trend comparisons, risk matrices
\end{itemize}

\subsubsection{Early Warning Page}
\begin{itemize}
    \item \textbf{Purpose}: Forecast future outbreaks and detect anomalies
    \item \textbf{Components}: 
    \begin{itemize}
        \item Alert threshold monitoring
        \item Anomaly detection indicators
        \item Short-term forecast (model-based)
        \item 24-month forecast projection
    \end{itemize}
    \item \textbf{ML Integration}: Real-time predictions from Voting Ensemble model
    \item \textbf{Visualizations}: Forecast line charts, cumulative projections, alert indicators
\end{itemize}

\subsubsection{Resource Planning Page}
\begin{itemize}
    \item \textbf{Purpose}: Support resource allocation decisions
    \item \textbf{Components}: Priority area identification, impact assessment, capacity planning
    \item \textbf{Features}: Risk scoring, resource requirement estimation, intervention prioritization
    \item \textbf{Visualizations}: Priority maps, impact charts, resource allocation matrices
\end{itemize}

\subsection{Backend API}

\subsubsection{Health Check Endpoint}
\begin{itemize}
    \item \textbf{Path}: \texttt{GET /health}
    \item \textbf{Purpose}: Verify API availability and model status
    \item \textbf{Response}: Model loaded status, model type
\end{itemize}

\subsubsection{Prediction Endpoint}
\begin{itemize}
    \item \textbf{Path}: \texttt{POST /api/predict}
    \item \textbf{Purpose}: Generate ML-based forecasts
    \item \textbf{Input}: Current metrics, historical context, temporal features
    \item \textbf{Output}: Prediction value, raw prediction, model type, metadata
    \item \textbf{Processing}:
    \begin{enumerate}
        \item Validate input data
        \item Build 36-dimensional feature vector
        \item Load appropriate model (lazy loading)
        \item Generate prediction
        \item Apply post-processing transformations
        \item Return JSON response
    \end{enumerate}
\end{itemize}

\subsection{Data Processing Utilities}

\subsubsection{Data Transformation Functions}
The \texttt{dataTransforms.js} module provides:

\begin{itemize}
    \item \textbf{Date Filtering}: Filter data by date ranges
    \item \textbf{Aggregation}: Calculate totals, averages, rates
    \item \textbf{Breakdown Analysis}: Regional, temporal, district-level breakdowns
    \item \textbf{Insight Generation}: Build insights for different analysis pages
    \item \textbf{Formatting}: Format numbers, dates, percentages
\end{itemize}

\section{Deployment}

\subsection{Deployment Architecture}

\subsubsection{Frontend Deployment}
\begin{itemize}
    \item \textbf{Platform}: Vercel (primary), GitHub Pages (alternative)
    \item \textbf{Build Tool}: Vite
    \item \textbf{Output}: Static files in \texttt{dist/} directory
    \item \textbf{Routing}: Client-side routing with React Router
    \item \textbf{Configuration}: \texttt{vercel.json} for routing and build settings
\end{itemize}

\subsubsection{Backend Deployment}
\begin{itemize}
    \item \textbf{Platform}: Vercel Serverless Functions
    \item \textbf{Runtime}: Python 3.11
    \item \textbf{Memory}: 2048 MB (Hobby plan limit)
    \item \textbf{Timeout}: 30 seconds
    \item \textbf{Model Loading}: Lazy loading to avoid build-time memory issues
\end{itemize}

\subsection{Deployment Configuration}

\subsubsection{Vercel Configuration}
The \texttt{vercel.json} file configures:
\begin{itemize}
    \item Build command: \texttt{npm run build}
    \item Output directory: \texttt{dist}
    \item API rewrites: Route \texttt{/api/*} to serverless function
    \item Frontend rewrites: Route all other paths to \texttt{index.html}
    \item Function settings: Memory, timeout, runtime
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \texttt{VITE\_API\_URL}: Frontend API endpoint URL
    \item \texttt{CUSTOM\_MODEL\_PATH}: Optional custom model path
    \item \texttt{PORT}: Server port (default: 5000)
\end{itemize}

\subsection{Model Deployment}

\subsubsection{Model File Management}
\begin{itemize}
    \item Models stored in parent \texttt{Cholera} directory
    \item Excluded from build process (via \texttt{.vercelignore})
    \item Uploaded separately to Vercel storage
    \item Lazy-loaded on first prediction request
\end{itemize}

\subsubsection{Memory Optimization}
\begin{itemize}
    \item Garbage collection before/after model loading
    \item Model caching to avoid repeated loads
    \item Error handling for memory constraints
    \item Fallback to smaller models if memory issues occur
\end{itemize}

\section{Performance and Results}

\subsection{Model Performance}

\subsubsection{Voting Ensemble Metrics}
\begin{itemize}
    \item \textbf{RMSE}: $\approx$ 10 cases (on test set)
    \item \textbf{$R^2$ Score}: $\approx$ 0.98
    \item \textbf{MAE}: Lower than individual base models
    \item \textbf{Prediction Time}: $<$ 100ms per prediction
\end{itemize}

\subsubsection{Forecast Accuracy}
\begin{itemize}
    \item Short-term forecasts (1-7 days): High accuracy
    \item Medium-term forecasts (1-3 months): Good accuracy
    \item Long-term forecasts (6-24 months): Trend-accurate, with increasing uncertainty
\end{itemize}

\subsection{System Performance}

\subsubsection{Frontend Performance}
\begin{itemize}
    \item \textbf{Initial Load}: $<$ 2 seconds
    \item \textbf{Page Transitions}: Smooth (60 FPS animations)
    \item \textbf{Chart Rendering}: $<$ 500ms for complex visualizations
    \item \textbf{Responsive Design}: Works on mobile, tablet, desktop
\end{itemize}

\subsubsection{API Performance}
\begin{itemize}
    \item \textbf{Health Check}: $<$ 50ms
    \item \textbf{Prediction Request}: $<$ 200ms (including model loading on first request)
    \item \textbf{Concurrent Requests}: Handles multiple simultaneous requests
    \item \textbf{Memory Usage}: $<$ 500 MB (excluding model)
\end{itemize}

\section{Conclusion}

The Cholera Watch platform represents a comprehensive solution for cholera surveillance and forecasting, combining modern web technologies with robust machine learning methodologies. The Voting Ensemble model selection, supported by extensive feature engineering, provides accurate and reliable predictions that support public health decision-making.

Key achievements:
\begin{itemize}
    \item Integrated dashboard with comprehensive analytics
    \item High-performance ML forecasting ($R^2 \approx 0.98$)
    \item Responsive design for multiple device types
    \item Scalable deployment architecture
    \item Real-time prediction capabilities
\end{itemize}

Future enhancements could include:
\begin{itemize}
    \item Real-time data streaming integration
    \item Additional ML models (neural networks, time series models)
    \item Advanced anomaly detection algorithms
    \item Mobile application development
    \item Multi-country support
\end{itemize}

\section{References}

\begin{itemize}
    \item Scikit-learn Documentation: \url{https://scikit-learn.org/}
    \item React Documentation: \url{https://react.dev/}
    \item Recharts Documentation: \url{https://recharts.org/}
    \item Leaflet Documentation: \url{https://leafletjs.com/}
    \item Vercel Documentation: \url{https://vercel.com/docs}
    \item Flask Documentation: \url{https://flask.palletsprojects.com/}
\end{itemize}

\appendix

\section{Code Examples}

\subsection{Feature Engineering Implementation}
\begin{lstlisting}[language=Python, caption=Feature Engineering Function (Excerpt)]
def build_features(data):
    """Build 36 features for ML model"""
    # Temporal features
    year = data.get('year', 2024)
    month = data.get('month', 1)
    
    # Cyclical encoding
    sin_month = math.sin(2 * math.pi * month / 12)
    cos_month = math.cos(2 * math.pi * month / 12)
    
    # Lag features
    historical = data.get('historicalSuspected', [])
    sCh_lag_1 = historical[-1] if len(historical) >= 1 else 0
    sCh_lag_7 = historical[-7] if len(historical) >= 7 else 0
    
    # Rolling statistics
    window_data = historical[-7:]
    rolling_mean_7 = sum(window_data) / len(window_data)
    
    # ... (additional features)
    
    return np.array([features])
\end{lstlisting}

\subsection{Model Loading}
\begin{lstlisting}[language=Python, caption=Model Loading with Priority]
# Model priority: Voting Ensemble > ElasticNet > Ridge > XGBoost > Lasso
if os.path.exists(VOTING_MODEL_PATH):
    MODEL_PATH = VOTING_MODEL_PATH
    MODEL_TYPE = 'voting_ensemble'
elif os.path.exists(ELASTICNET_MODEL_PATH):
    MODEL_PATH = ELASTICNET_MODEL_PATH
    MODEL_TYPE = 'elasticnet'
# ... (additional fallbacks)
\end{lstlisting}

\section{Model Comparison Table}

\begin{table}[H]
\centering
\caption{Model Performance Comparison}
\begin{tabular}{lccc}
\toprule
\textbf{Model} & \textbf{RMSE} & \textbf{$R^2$} & \textbf{MAE} \\
\midrule
Voting Ensemble & $\approx$ 10 & $\approx$ 0.98 & Lowest \\
ElasticNet & $\approx$ 12 & $\approx$ 0.96 & Low \\
Ridge Regression & $\approx$ 13 & $\approx$ 0.95 & Medium \\
XGBoost & $\approx$ 11 & $\approx$ 0.97 & Low \\
Lasso Regression & $\approx$ 14 & $\approx$ 0.94 & Medium \\
\bottomrule
\end{tabular}
\end{table}

\end{document}

